"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _lodash = require("lodash");

var _promisePropsRecursive = _interopRequireDefault(require("promise-props-recursive"));

var _semverCompare = _interopRequireDefault(require("semver-compare"));

var _getLatestVersion = _interopRequireDefault(require("get-latest-version"));

var _dynamicRequire = _interopRequireDefault(require("../../util/dynamicRequire"));

var _getLocalVersion = _interopRequireDefault(require("../../util/getLocalVersion"));

var _package = _interopRequireDefault(require("../../../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Some packages can introduce errors when updating. For example with Sanity UI
 * we are at the moment dependant upon the version of @sanity/ui that
 * @sanity/base imports to be the only version used since all imports of UI
 * need to use the same context.
 *
 * Put them in this array to make sure the upgrade script doesn't upgrade
 * them.
 */
const PACKAGES_TO_EXCLUDE = ['@sanity/ui'];
const defaultOptions = {
  includeCli: true
};

var _default = async (context, target, opts = {}) => {
  const {
    spinner
  } = context.output;
  const options = Object.assign({}, defaultOptions, opts);
  const sanityModules = filterSanityModules(getLocalManifest(context.workDir));
  const resolveOpts = {
    includeCli: options.includeCli,
    target
  };
  const spin = spinner('Resolving latest versions').start();
  const versions = await (0, _promisePropsRecursive.default)(buildPackageArray(sanityModules, context.workDir, resolveOpts));
  const packages = (0, _lodash.values)(versions);
  spin.stop();
  return packages.map(mod => {
    mod.needsUpdate = target === 'latest' ? (0, _semverCompare.default)(mod.version, mod.latest) === -1 : mod.version !== mod.latest;
    return mod;
  });
};

exports.default = _default;

function getLocalManifest(workDir) {
  try {
    return (0, _dynamicRequire.default)(_path.default.join(workDir, 'package.json'));
  } catch (err) {
    return {};
  }
}

function filterSanityModules(manifest) {
  const dependencies = Object.assign({}, manifest.dependencies || {}, manifest.devDependencies || {});
  const sanityDeps = Object.keys(dependencies).filter(mod => mod.indexOf('@sanity/') === 0).filter(mod => !PACKAGES_TO_EXCLUDE.includes(mod)).sort();
  return sanityDeps.reduce((versions, dependency) => {
    const version = dependencies[dependency];
    versions[dependency] = version.indexOf('^') === 0 ? 'latest' : version;
    return versions;
  }, {});
}

function buildPackageArray(packages, workDir, options = {}) {
  const {
    includeCli,
    target
  } = options;
  const initial = [];

  if (includeCli) {
    initial.push({
      name: _package.default.name,
      version: _package.default.version,
      latest: tryFindLatestVersion(_package.default.name, target)
    });
  }

  return Object.keys(packages).reduce((result, pkgName) => {
    result.push({
      name: pkgName,
      version: (0, _getLocalVersion.default)(pkgName, workDir) || '???',
      latest: tryFindLatestVersion(pkgName, target)
    });
    return result;
  }, initial);
}

function tryFindLatestVersion(pkgName, range = 'latest') {
  return (0, _getLatestVersion.default)(pkgName, range).catch(() => 'unknown');
}